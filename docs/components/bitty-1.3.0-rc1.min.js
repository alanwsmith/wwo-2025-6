function t() {
  return self.crypto.randomUUID();
}
const e = [1, 3, 0], s = `bitty-${e[0]}-${e[1]}`;
class n extends HTMLElement {
  constructor() {
    super(),
      this.config = { listeners: ["click", "input"] },
      this.metadata = {
        copyright: "Copyright 2025 - Alan W. Smith",
        license:
          "License at: htttp://bitty.alanwsmith.com/ - 2y1pBoEREr3eWA1ubCCOXdmRCdn",
        version: e,
      };
  }
  async connectedCallback() {
    this.dataset.uuid = t(),
      this.receivers = [],
      this.setIds(),
      await this.makeConnection(),
      this.conn && (this.conn.api = this,
        this.handleEventBridge = this.handleEvent.bind(this),
        this.watchMutations = this.handleMutations.bind(this),
        this.loadReceivers(),
        this.addObserver(),
        this.addEventListeners(),
        await this.callBittyInit(),
        this.runSendFromComponent());
  }
  addEventListeners() {
    this.dataset.listeners &&
    (this.config.listeners = this.dataset.listeners.split("|").map((t) =>
      t.trim()
    )),
      this.config.listeners.forEach((e) => {
        document.addEventListener(e, (e) => {
          e.target && e.target.nodeName.toLowerCase() !== s &&
            e.target.dataset && e.target.dataset.send &&
            (e.uuid = t(), this.handleEventBridge.call(this, e));
        });
      });
  }
  addObserver() {
    this.observerConfig = { childList: !0, subtree: !0 },
      this.observer = new MutationObserver(this.watchMutations),
      this.observer.observe(this, this.observerConfig);
  }
  addReceiver(t, e) {
    this.conn[t] && this.receivers.push({
      key: t,
      f: (s) => {
        this.conn[t](s, e);
      },
    });
  }
  async callBittyInit() {
    "function" == typeof this.conn.bittyInit &&
      ("AsyncFunction" === this.conn.bittyInit[Symbol.toStringTag]
        ? await this.conn.bittyInit()
        : this.conn.bittyInit());
  }
  async fetchJson(t) {
    let e = await fetch(t);
    try {
      if (e.ok) return await e.json();
      throw new Error(`${e.status} [${e.statusText}] - ${t}`);
    } catch (e) {
      return void console.error(`fetchJson Error [${t}] - ${e}`);
    }
  }
  forward(t, e) {
    t && t.target && t.target.dataset ||
    (t = { type: "bittyforward", target: { dataset: { forward: e } } }),
      t.target.dataset.forward = e,
      this.handleEvent(t);
  }
  handleEvent(t) {
    let e = null;
    t.target.dataset.forward
      ? (e = t.target.dataset.forward, delete t.target.dataset.forward)
      : e = t.target.dataset.send, this.processSignals(t, e);
  }
  handleMutations(t, e) {
    for (const e of t) {
      "childList" === e.type &&
        (e.addedNodes.length > 0 || e.removedNodes.length > 0) &&
        (this.setIds(), this.loadReceivers());
    }
  }
  loadReceivers() {
    this.receivers = [],
      this.querySelectorAll("[data-receive]").forEach((t) => {
        t.dataset.receive.split("|").forEach((e) => {
          this.addReceiver(e, t);
        });
      });
  }
  async makeConnection() {
    try {
      if (this.dataset.connect) {
        const t = this.dataset.connect.split("|");
        if (void 0 !== window[t[0]]) this.conn = new window[t[0]]();
        else {
          const e = await import(t[0]);
          void 0 === t[1]
            ? this.conn = new e.default()
            : this.conn = new e[t[1]]();
        }
      } else {window.BittyClass
          ? this.conn = new window.BittyClass()
          : console.error(`${s} error: No class to connect to.`);}
    } catch (t) {
      console.error(`${s} error: ${t}`);
    }
  }
  processSignals(t, e) {
    e.split("|").forEach((e) => {
      let s = 0;
      this.receivers.forEach((n) => {
        n.key === e && (s += 1, n.f(t));
      }), 0 === s && this.conn[e] && this.conn[e](t, null);
    });
  }
  runSendFromComponent() {
    this.dataset.send &&
      this.handleEvent({ type: "bittytagdatasend", uuid: t(), target: this });
  }
  setIds() {
    this.querySelectorAll("*").forEach((e) => {
      e.dataset.uuid || (e.dataset.uuid = t());
    });
  }
  useTemplate(t, e) {
    for (let s of Object.keys(e)) t = t.replaceAll(s, e[s]);
    const s = document.createElement("template");
    return s.innerHTML = t, s.content.cloneNode(!0);
  }
}
customElements.define(s, n);

